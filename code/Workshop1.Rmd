---
title: "MB5370 Module 04. Workshop 1 - Introduction"
author: "Ben Cresswell"
output: html_document
date: "2024-03-22"
---

# Workshop 1 Session 2: Dataviz in R
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Install and load tidyverse packages
```{r}
## install.packages("tidyverse") # Delete this line once installed
library("tidyverse")
library("ggplot2")
```


# Load the data (mpg is built into ggplot2)
```{r}
mpg
?mpg
```


# Quick data checks
```{r}
head(mpg)
glimpse(mpg)
summary(mpg)
```


# Create first plot
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

The plot shows a negative relationship between engine size (displ) and fuel efficiency (hwy). In other words, cars with big engines use more fuel. What does this say about fuel efficiency and engine size?



# Understanding grammar of graphics
What happens if we just try to run ggplot on its own?
```{r}
ggplot() 
#result is a blank white square (did not add any data layer)

# Or with just the data specified?
ggplot(data = mpg)
#same result
```

We need to map some aesthetics!!

# When you’re creating a plot, you essentially need two attributes of a plot: a geom and aesthetics.
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, colour = class))
```

# Change point colour by class:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, colour = class))
```

# Change point size by class:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))
```
Note the warning!!!

# Change transparency (alpha) by class
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))
```
Another warning!!
Question: When would using alpha (or size be appropriate??)
Alpha and size would be appropriate when using a continuous variable to limit overlapping data

# Change point shape by class:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))
```


# Make all points blue
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```

# Troubleshooting 

# Faceting

## facet_wrap
Split the plot out by car type (class)
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)
```

## facet_grid
A separate facet for each combination of drive-type (e.g. 4WD) * number of cylinders
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ cyl)
```
Note that there are no occurrences of 5 cylinder 4WDs OR RWD vehicles!

## facet_grid by just row (or column)
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(cyl ~ .)
  #facet_grid(. ~ cyl) # Alternatively

```

# Exercise:
Read ?facet_wrap. What does nrow do? What does ncol do? What other options control the layout of the individual panels? 

```{r}
?facet_wrap
#nrow defines the number of rows of data (number of different graphs) you want to add --> defines the layout of the facets
#ncol defines the number of columns of data (number of different graphs) you want to add --> defines the layout of the facets
```

# Lines
We already used points:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

However, ggplot2 can use a variety of geom objects to represent the data. Here, we might want to use bar plots, line charts, boxplots and so on. Well we can handle this issue in ggplot directly using a different geom to plot the same data. Here, instead of plotting points, we will use a smooth line. 

# To display the same data as a smooth line fit through the points use geom_smooth().
```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```
### Question: whey don't we use geom_line() here? What would that look like? ###
Since the data is discrete, a geom_line would not "fit" the data well so by smoothing it out we can reveal the real, non-linear trend of the data across the discrete x variables

So let’s recap. A geom is an object that your plot uses to represent the data. To change the geom type in your plot, simply change the geom function that you add to your plot template. Sometimes you may want to try a few things out, in which case you could use comments to help you remember what worked and what didn’t. 

## Using comments (#)
```{r}
ggplot(data = mpg) + 
  #geom_point(mapping = aes(x = displ, y = hwy)) + # points horrible 
  geom_smooth(mapping = aes(x = displ, y = hwy)) # try smooth line
```

Question: how does R work out where to plot the line??? Can use the chunk output to inform us. Can also use the help menu.

R uses the loess smooth message to determine the non-linear y~x relationship across the discrete variable "displ" --> aesthetically "maps" the data

# Changing linetype
```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv)) # Can also use "lty = " for the same result
```

# Grouping
```{r}
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))
```
 
# Change line colour based on drv value
```{r}
ggplot(data = mpg) +
  geom_smooth(
    mapping = aes(x = displ, y = hwy, color = drv),
    show.legend = FALSE,
  )
```

# Multiple geoms
We already did this one way
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

A better way...creates global mappings that are applied to all subsequent geom in the code for the ggplot
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```

# Can still manipulate each geom/layer separately:
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth()
```

Now we have different colours to indicate the raw data (geom_point) and one colour for the overall relationship (geom_smooth). Neat!

Here, we use a filter (class = "subcompact") to select a subset of the data and plot only that subset. 
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth(data = filter(mpg, class == "subcompact"), se = FALSE)
```
Question: what does the "se = FALSE" do?

It removes the 95% confidence interval (standard error) shade around the line

# Exercise:
1.  What geom would you use to draw a line chart? A boxplot? A histogram? An area chart?
2.  Run this code in your head and predict what the output will look like. Then, run the code in R and check your predictions.

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_line(mapping = aes(color = class))

ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_boxplot(mapping = aes(color = class))

ggplot(mpg, aes(x = displ, fill = class)) +
  geom_histogram(binwidth = 0.5, color = "black", position = "dodge")

ggplot(mpg, aes(x = displ, y = hwy, fill = class)) +
  geom_area(alpha = 0.6, position = "stack")

```

3.  Will these two graphs look different? Why/why not?

They will not look different. The first graph is using the global mapping of the aesthetics which impacts the aesthetics of all geom in the ggplot. The second graph is doing mapping for each geom but the results should be the same.
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()

ggplot() + 
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))
```

# Transformations and stats

## Load data
```{r}
diamonds
glimpse(diamonds)
```

# Bar plot
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))

#stat_count can be used interchangeably with geom_bar --> makes the same graph
ggplot(data = diamonds)+
  stat_count(mapping = aes(x = cut))
```

# Overriding defaults
Make some new data
```{r}
demo <- tribble(
  ~cut,         ~freq,
  "Fair",       1610,
  "Good",       4906,
  "Very Good",  12082,
  "Premium",    13791,
  "Ideal",      21551
)
demo
```

```{r}
ggplot(data = demo) +
  geom_bar(mapping = aes(x = cut, y = freq), stat = "identity")
```
Question: Why did we now specify a y axis?

Because we are not plotting raw count data --> we are plotting the frequency

# What if we want to know the proportion rather than the absolute frequency?
```{r}
#changes the order of the variables on the x axis from lowest quality to highest
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = after_stat(prop), group = 1))
```

Question: does anyone get the warning that's in the workbook?
Warning: `stat(prop)` was deprecated in ggplot2 3.4.0.
If so, can use # geom_bar(mapping = aes(x = cut, y = stage(after_stat = prop), group = 1))

Yes

# Plotting statistical details (know more about transformations: helpful when looking at uncertainties/limitations in data)
```{r}
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.min = min,
    fun.max = max,
    fun = median
  )
```

# Aesthetic adjustments adjustments
Another way to boost the way you can convey information with plots using ggplot2 is to use aesthetics like colour or fill to change aspects of bar colours. We already did this once, but there are multiple options available to you, including changing the fill our outline colours.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, colour = cut))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
```
Question: Does anyone notice anything different in the colour scheme of this plot?
(Hint: It's in the viridis colour palette (colour blind friendly), but why is it different from the colour palette we used earlier?)

We used fill = instead of y = in the mapping of the aesthetics, didn't use color = which calls in the generic R colors (that suck)

Check out the difference:
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) 

ggplot(data = diamonds, mapping = aes(x = color, y = depth)) + 
  geom_point(mapping = aes(color = cut)) 
```

# Filling by a variable
Now try using these aesthetics to colour by another variable like clarity. Notice how the stacking is done automatically. This is done behind the scenes with a position argument.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```
The ability to make position adjustments is vital, it allows you to customise your plots in three ways, identity (raw data), fill (changes heights) and dodge (which forces ggplot2 to not put things on top of each other)

# To alter transparency (alpha)
```{r}
ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
  geom_bar(alpha = 1/5, position = "identity")
```

# To color the bar outlines with no fill color
```{r}
ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + 
  geom_bar(fill = NA, position = "identity")
```

# Position adjustments
position = "fill" works like stacking, but makes each set of stacked bars the same height.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")
```
df <- read.csv("data/QLDSCP_ray.csv")
# position = "dodge" 
Places overlapping objects directly beside one another.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
```

# Jittering
position = "jitter" adds a small amount of random noise to each point to avoid overplotting when points overlap. This is useful for scatterplots but not barplots.
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
  #geom_point(mapping = aes(x = displ, y = hwy))
```

# Workshop 2: Using ggplot2 for communication

In ggplot2, you add labels with the labs() function, let's start with a title
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se.e = FALSE) +
  labs(title = "Fuel efficiency generally decreases with engine size")
```
If you need to add more text, you can use a couple of other functions:
subtitle adds additional detail in a smaller font beneath the title and caption adds text at the bottom right of the plot
caption adds text at the bottom right of the plot, often used to describe the source of the data
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(
    title = "Fuel efficiency generally decreases with engine size",
    subtitle = "Two seaters (sports cars) are an exception because of their light weight",
    caption = "Data from fueleconomy.gov"
  )

#You can also use labs() to replace axis labels and legend titles
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_smooth(se = FALSE) +
  labs(
    x = "Engine displacement (L)",
    y = "Highway fuel economy (mpg)",
    colour = "Car type"
  )
```
# Annotations

If you want to add text to the plot itself, you can use geom_text() to add textual labels to your plot. This functions similarly to geom_point () but rather than a shape geometry, it can add a label.

Here, we filter the data and add a label that calls in the values from the dataframe. This allows us to pull data values out (like the most fuel efficient car) from the data itself and include it in the plot.
```{r}
best_in_class <- mpg %>%
  group_by(class) %>%
  filter(row_number(desc(hwy)) == 1)

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_text(aes(label = model), data = best_in_class)
```
Although the labels overlap, there are ways you can handle that issue if you ever find a problem. These include the nudge() function to move your text a certain amount and using other R packages to handle text wrapping, etc.

Labels are super flexible and they allow you to develop professional and polished outputs

# Scales

Changing default scales on ggplot2 can help you customize your plots and improve communication of your results.

Normally, ggplot adds scales for you:
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))
```
ggplot2 automatically adds default scales behind the scenes.

If you want to tweak them, you can offer values to the scale parameters by adding numbers in the appropriate scale arguments

To provide limits, you need to offer a character vector showing the start and end of your limit (e.g. c(01,12)). ?scale_x_continuous() has plenty of other arguments so don't forget to explicitly state the argument you're providing these limits (e.g. limits = c(0,12))
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous() +
  scale_y_continuous() +
  scale_colour_discrete()
```
# Axis ticks

You can also change the ticks on your axes. Breaks control the position of the ticks and you can use labels as an argument to change the text label associated with ticks
```{r}
ggplot(mpg, aes(displ,hwy)) +
  geom_point() +
  scale_y_continuous(breaks = seq(15, 40, by = 5))

#What does seq do? Try running:
seq(15, 40, by = 5)
#seq tells us the sequence of numbers that we want along the y axis. 15 and 40 are the start and end values and by = 5 tells us we want it to count up by 5 (break at each interval of 5)
```

Similarly, you can use labels set to NULL to suppress the labels altogether. This is sometimes an option if you're trying to format your plots in a particular way.
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  scale_x_continuous(labels = NULL) +
  scale_y_continuous(labels = NULL)
```
# Legengs and color schemes

Sometimes you might want to change the position of your legend, for example if you want to make the plot as wide as possible (put the legend underneath) or hide it altogether.

To control the overall position of the legend, you need to use a theme() setting.

Run each line separately to see how it changes the plot of "base."
```{r}
base <- ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))

base + theme(legend.position = "left")
base + theme(legend.position = "top")
base + theme(legend.position = "bottom")
base + theme(legend.position = "right") # the default
```
You can also use legend.position = "none" to suppress the display of the legend altogether

# Replacing a scale

There are two types of scales you will focus on : continuous position scales and color scales

It's useful to plot transformations of your variables. For example, as we've seen in diamond prices it's easier to see the precise relationship between carat and price if we log transform them using a ggplot2 function for scale precisely for this purpose
```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_bin2d() + 
  scale_x_log10() + 
  scale_y_log10()
```
Another scale that is frequently customised is the color scale. This is one of the most important changes you can make to a base ggplot
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv))

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv)) +
  scale_colour_brewer(palette = "Set1")
```
If there are just a few colors, you can add a redundant shape mapping. This will also help ensure your plot is interpretable in black and white
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv, shape = drv)) +
  scale_colour_brewer(palette = "Set1")
```
ColorBrewer scales are documented online at http://colorbrewer2.org/. There are a range of different color schemes you can import such as this, so read more about them in the ggplot2 cookbook: http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/

When you have predefined colors you want to use you can set them yourself using scale_color_manual()
```{r}
presidential %>%
  mutate(id = 33 + row_number()) %>%
  ggplot(aes(start, id, colour = party)) +
    geom_point() +
    geom_segment(aes(xend = end, yend = id)) +
    scale_colour_manual(values = c(Republican = "red", Democratic = "blue"))
```
One of the most popular color packages is the viridis colour scheme

To use it, simply use scale_colour_viridis() provide by the viridis package
```{r}
#install.packages('viridis')
#install.packages('hexbin')
#library(viridis)
#library(hexbin)

df <- tibble ( #we are making a fake dataset
  x = rnorm(10000),
  y = rnorm(10000)
)
ggplot(df, aes(x,y)) +
  geom_hex() +
  coord_fixed()

ggplot(df, aes(x,y)) +
  geom_hex() +
  viridis::scale_fill_viridis() +
  coord_fixed()
```
There are other interesting color schemes, such as the Wes Anderson color palette.

# Themes

Now you can customize the entire theme of your plot. Themes allow you to change some or all of the non-data elements of your plot with a theme

ggplot2 has 8 themes by default. Many more are included in add-on packages like ggthemes (https://github.com/jrnold/ggthemes)
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_bw()

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_light()

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_classic()

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_dark()
```
One nice thing you can do is to develop your own themes by setting some/all of the argumetns to theme() yourself.

Here's an example
```{r}
theme (panel.border = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position="bottom",
        legend.title=element_blank(),
        legend.text=element_text(size=8),
        panel.grid.major = element_blank(),
        legend.key = element_blank(),
        legend.background = element_blank(),
        axis.text.y=element_text(colour="black"),
        axis.text.x=element_text(colour="black"),
        text=element_text(family="Arial")) 
```
# Saving and exporting your plots

Now that you've developed your plot, you want to save it to disk in some format that allows you to import it to your report or to share it with the world.

In general, the best way to make a single file will be to export it using the ggsave() function

There are two main ways to get your plots out of R using ggplot2. ggsave() will save the most recent plot to your working directory
```{r}
ggplot(mpg, aes(displ, hwy)) + geom_point()

ggsave("my-plot.pdf")

ggsave("my-plot1.pdf",
       width = 8, height = 10)
```
Sometimes you'll want to play with your plot dimensions of your plot, you can use the width and height arguments to this function





